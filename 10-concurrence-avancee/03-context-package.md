üîù Retour au [Sommaire](/SOMMAIRE.md)

# 10-3 : Context package

## Introduction

Le package `context` est l'un des outils les plus importants pour g√©rer la concurrence en Go. Il permet de g√©rer les **timeouts**, l'**annulation** de t√¢ches, et le **passage de valeurs** entre goroutines. Si vous d√©veloppez des applications Go pour la production, ma√Ætriser le context est essentiel.

## Qu'est-ce qu'un Context ?

Un **Context** est comme un "signal de contr√¥le" qui voyage avec vos goroutines. Il peut porter trois types d'informations :

1. **Signal d'annulation** : "Arr√™te ce que tu fais"
2. **Deadline/Timeout** : "Tu as jusqu'√† telle heure pour finir"
3. **Valeurs** : "Voici des donn√©es que tu peux utiliser"

### Analogie du monde r√©el

Imaginez que vous √™tes un chef de projet qui envoie des √©quipes sur diff√©rentes missions :

- **Timeout** : "Vous avez 2 heures maximum pour cette mission"
- **Annulation** : "Mission annul√©e, revenez imm√©diatement"
- **Valeurs** : "Voici l'ID de mission et les cl√©s d'acc√®s"

C'est exactement ce que fait un Context !

## Concepts de base

### Interface Context

```go
type Context interface {
    // Deadline retourne le moment o√π le context expire
    Deadline() (deadline time.Time, ok bool)

    // Done retourne un channel qui se ferme quand le context est annul√©
    Done() <-chan struct{}

    // Err retourne l'erreur si le context est annul√©
    Err() error

    // Value retourne la valeur associ√©e √† une cl√©
    Value(key interface{}) interface{}
}
```

### Les quatre types de Context

1. **Background** : Context racine, jamais annul√©
2. **WithCancel** : Peut √™tre annul√© manuellement
3. **WithTimeout** : S'annule apr√®s un d√©lai
4. **WithDeadline** : S'annule √† un moment pr√©cis

## 1. Context Background

C'est le context de base, point de d√©part de tous les autres.

```go
package main

import (
    "context"
    "fmt"
)

func basicContextExample() {
    // Cr√©er un context de base
    ctx := context.Background()

    fmt.Printf("Context cr√©√©: %v\n", ctx)
    fmt.Printf("Deadline: %v\n", ctx.Deadline())  // false, pas de deadline
    fmt.Printf("Done channel: %v\n", ctx.Done())  // nil, jamais ferm√©
    fmt.Printf("Error: %v\n", ctx.Err())          // nil, pas d'erreur
}
```

**Utilisation** : Point de d√©part dans `main()`, tests, ou quand aucune annulation n'est n√©cessaire.

## 2. Context avec annulation manuelle

### WithCancel

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func cancelContextExample() {
    // Cr√©er un context avec possibilit√© d'annulation
    ctx, cancel := context.WithCancel(context.Background())

    // Lancer une goroutine qui fait du travail
    go func() {
        for {
            select {
            case <-ctx.Done():
                fmt.Println("üõë Goroutine arr√™t√©e:", ctx.Err())
                return
            default:
                fmt.Println("‚öôÔ∏è Travail en cours...")
                time.Sleep(500 * time.Millisecond)
            }
        }
    }()

    // Laisser tourner 2 secondes puis annuler
    time.Sleep(2 * time.Second)
    fmt.Println("üì¢ Annulation du context...")
    cancel() // D√©clenche l'annulation

    // Attendre que la goroutine se termine
    time.Sleep(100 * time.Millisecond)
    fmt.Println("‚úÖ Programme termin√©")
}
```

### Sortie attendue

```
‚öôÔ∏è Travail en cours...
‚öôÔ∏è Travail en cours...
‚öôÔ∏è Travail en cours...
‚öôÔ∏è Travail en cours...
üì¢ Annulation du context...
üõë Goroutine arr√™t√©e: context canceled
‚úÖ Programme termin√©
```

### Exemple avec plusieurs goroutines

```go
func multipleGoRoutinesCancel() {
    ctx, cancel := context.WithCancel(context.Background())

    // Lancer plusieurs workers
    for i := 1; i <= 3; i++ {
        go worker(ctx, i)
    }

    // Annuler apr√®s 3 secondes
    time.Sleep(3 * time.Second)
    fmt.Println("üì¢ Arr√™t de tous les workers...")
    cancel()

    time.Sleep(500 * time.Millisecond)
}

func worker(ctx context.Context, id int) {
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("üõë Worker %d arr√™t√©: %v\n", id, ctx.Err())
            return
        default:
            fmt.Printf("üë∑ Worker %d travaille...\n", id)
            time.Sleep(800 * time.Millisecond)
        }
    }
}
```

## 3. Context avec timeout

### WithTimeout

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func timeoutContextExample() {
    // Context qui s'annule automatiquement apr√®s 2 secondes
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel() // Bonne pratique : toujours appeler cancel()

    go func() {
        for {
            select {
            case <-ctx.Done():
                fmt.Println("‚è∞ Timeout atteint:", ctx.Err())
                return
            default:
                fmt.Println("üîÑ Traitement en cours...")
                time.Sleep(500 * time.Millisecond)
            }
        }
    }()

    // Attendre que le timeout se d√©clenche
    time.Sleep(3 * time.Second)
    fmt.Println("‚úÖ Fin du programme")
}
```

### Exemple pratique : Appel HTTP avec timeout

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// Simulation d'un appel HTTP
func fetchData(ctx context.Context, url string) (string, error) {
    // Channel pour recevoir le r√©sultat
    resultChan := make(chan string, 1)
    errorChan := make(chan error, 1)

    // Lancer la requ√™te dans une goroutine
    go func() {
        // Simulation d'un appel qui prend du temps
        fmt.Printf("üåê D√©but de la requ√™te vers %s...\n", url)
        time.Sleep(3 * time.Second) // Simulation latence r√©seau

        // V√©rifier si le context n'est pas annul√©
        select {
        case <-ctx.Done():
            errorChan <- ctx.Err()
            return
        default:
            resultChan <- fmt.Sprintf("Donn√©es de %s", url)
        }
    }()

    // Attendre le r√©sultat ou le timeout
    select {
    case result := <-resultChan:
        return result, nil
    case err := <-errorChan:
        return "", err
    case <-ctx.Done():
        return "", ctx.Err()
    }
}

func httpTimeoutExample() {
    // Context avec timeout de 2 secondes
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    start := time.Now()

    data, err := fetchData(ctx, "https://api.example.com/data")

    elapsed := time.Since(start)

    if err != nil {
        fmt.Printf("‚ùå Erreur apr√®s %v: %v\n", elapsed, err)
    } else {
        fmt.Printf("‚úÖ Succ√®s apr√®s %v: %s\n", elapsed, data)
    }
}
```

## 4. Context avec deadline

### WithDeadline

```go
func deadlineContextExample() {
    // Context qui expire √† un moment pr√©cis
    deadline := time.Now().Add(1500 * time.Millisecond)
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()

    fmt.Printf("‚è∞ Deadline fix√©e √†: %v\n", deadline.Format("15:04:05.000"))

    go func() {
        for {
            select {
            case <-ctx.Done():
                fmt.Printf("‚è∞ Deadline atteinte √† %v: %v\n",
                          time.Now().Format("15:04:05.000"), ctx.Err())
                return
            default:
                fmt.Printf("üîÑ Travail en cours √† %v\n",
                          time.Now().Format("15:04:05.000"))
                time.Sleep(300 * time.Millisecond)
            }
        }
    }()

    time.Sleep(2 * time.Second)
}
```

## 5. Context avec valeurs

### WithValue

```go
package main

import (
    "context"
    "fmt"
)

// Cl√©s typ√©es pour √©viter les collisions
type contextKey string

const (
    UserIDKey    contextKey = "userID"
    RequestIDKey contextKey = "requestID"
)

func contextWithValuesExample() {
    // Context avec des valeurs
    ctx := context.Background()

    // Ajouter des valeurs
    ctx = context.WithValue(ctx, UserIDKey, "user123")
    ctx = context.WithValue(ctx, RequestIDKey, "req456")

    // Passer le context √† une fonction
    processRequest(ctx)
}

func processRequest(ctx context.Context) {
    // R√©cup√©rer les valeurs du context
    userID := ctx.Value(UserIDKey)
    requestID := ctx.Value(RequestIDKey)

    fmt.Printf("üë§ Traitement pour l'utilisateur: %v\n", userID)
    fmt.Printf("üìù ID de requ√™te: %v\n", requestID)

    // Passer √† d'autres fonctions
    saveToDatabase(ctx)
    sendNotification(ctx)
}

func saveToDatabase(ctx context.Context) {
    userID := ctx.Value(UserIDKey)
    fmt.Printf("üíæ Sauvegarde en base pour l'utilisateur: %v\n", userID)
}

func sendNotification(ctx context.Context) {
    userID := ctx.Value(UserIDKey)
    requestID := ctx.Value(RequestIDKey)
    fmt.Printf("üìß Notification envoy√©e (user: %v, req: %v)\n", userID, requestID)
}
```

### Bonnes pratiques pour les valeurs

```go
// ‚úÖ Utiliser des types personnalis√©s pour les cl√©s
type userContextKey struct{}
type requestContextKey struct{}

func betterContextValues() {
    ctx := context.Background()

    // Cl√©s typ√©es (plus s√ªr)
    ctx = context.WithValue(ctx, userContextKey{}, "user123")
    ctx = context.WithValue(ctx, requestContextKey{}, "req456")

    // Helper functions pour type safety
    userID := getUserID(ctx)
    requestID := getRequestID(ctx)

    fmt.Printf("User: %s, Request: %s\n", userID, requestID)
}

// Helper functions pour extraire les valeurs
func getUserID(ctx context.Context) string {
    if userID, ok := ctx.Value(userContextKey{}).(string); ok {
        return userID
    }
    return ""
}

func getRequestID(ctx context.Context) string {
    if reqID, ok := ctx.Value(requestContextKey{}).(string); ok {
        return reqID
    }
    return ""
}
```

## Combinaison de contexts

### Timeout + Valeurs + Annulation

```go
func combinedContextExample() {
    // Context de base avec valeurs
    ctx := context.Background()
    ctx = context.WithValue(ctx, UserIDKey, "user789")

    // Ajouter un timeout
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()

    // Lancer plusieurs t√¢ches
    done := make(chan bool, 2)

    go longRunningTask(ctx, "T√¢che 1", done)
    go longRunningTask(ctx, "T√¢che 2", done)

    // Arr√™ter manuellement apr√®s 2 secondes pour montrer l'annulation
    go func() {
        time.Sleep(2 * time.Second)
        fmt.Println("üì¢ Annulation manuelle...")
        cancel()
    }()

    // Attendre que les t√¢ches se terminent
    for i := 0; i < 2; i++ {
        <-done
    }

    fmt.Println("‚úÖ Toutes les t√¢ches termin√©es")
}

func longRunningTask(ctx context.Context, name string, done chan<- bool) {
    defer func() {
        done <- true
    }()

    userID := ctx.Value(UserIDKey)
    fmt.Printf("üöÄ %s d√©marr√©e pour l'utilisateur %v\n", name, userID)

    for i := 1; i <= 10; i++ {
        select {
        case <-ctx.Done():
            fmt.Printf("üõë %s arr√™t√©e √† l'√©tape %d: %v\n", name, i, ctx.Err())
            return
        default:
            fmt.Printf("‚öôÔ∏è %s - √©tape %d/10\n", name, i)
            time.Sleep(500 * time.Millisecond)
        }
    }

    fmt.Printf("‚úÖ %s termin√©e avec succ√®s\n", name)
}
```

## Context dans un serveur HTTP

### Exemple pratique avec serveur

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "time"
)

func contextHTTPServerExample() {
    http.HandleFunc("/api/data", dataHandler)
    http.HandleFunc("/api/slow", slowHandler)

    fmt.Println("üöÄ Serveur d√©marr√© sur :8080")
    fmt.Println("Testez avec:")
    fmt.Println("  curl http://localhost:8080/api/data")
    fmt.Println("  curl http://localhost:8080/api/slow")

    http.ListenAndServe(":8080", nil)
}

func dataHandler(w http.ResponseWriter, r *http.Request) {
    // Le context de la requ√™te HTTP
    ctx := r.Context()

    // Ajouter des informations au context
    ctx = context.WithValue(ctx, RequestIDKey, generateRequestID())

    // Traiter la requ√™te avec le context
    result, err := processDataRequest(ctx)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    fmt.Fprintf(w, "R√©sultat: %s\n", result)
}

func slowHandler(w http.ResponseWriter, r *http.Request) {
    // Context avec timeout pour cette requ√™te
    ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
    defer cancel()

    result, err := slowOperation(ctx)
    if err != nil {
        if err == context.DeadlineExceeded {
            http.Error(w, "Timeout: op√©ration trop lente", http.StatusRequestTimeout)
            return
        }
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    fmt.Fprintf(w, "R√©sultat lent: %s\n", result)
}

func processDataRequest(ctx context.Context) (string, error) {
    requestID := ctx.Value(RequestIDKey)

    // Simulation d'un traitement rapide
    select {
    case <-time.After(100 * time.Millisecond):
        return fmt.Sprintf("Donn√©es trait√©es (ID: %v)", requestID), nil
    case <-ctx.Done():
        return "", ctx.Err()
    }
}

func slowOperation(ctx context.Context) (string, error) {
    // Simulation d'une op√©ration qui prend 5 secondes
    select {
    case <-time.After(5 * time.Second):
        return "Op√©ration lente termin√©e", nil
    case <-ctx.Done():
        return "", ctx.Err()
    }
}

func generateRequestID() string {
    return fmt.Sprintf("req_%d", time.Now().UnixNano())
}
```

## Context avec base de donn√©es

### Exemple avec requ√™tes DB

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// Simulation d'une base de donn√©es
type Database struct {
    name string
}

func (db *Database) Query(ctx context.Context, query string) ([]string, error) {
    fmt.Printf("üóÑÔ∏è Ex√©cution de la requ√™te: %s\n", query)

    // Simulation d'une requ√™te qui prend du temps
    select {
    case <-time.After(1 * time.Second):
        return []string{"r√©sultat1", "r√©sultat2", "r√©sultat3"}, nil
    case <-ctx.Done():
        fmt.Printf("‚ùå Requ√™te annul√©e: %v\n", ctx.Err())
        return nil, ctx.Err()
    }
}

func databaseContextExample() {
    db := &Database{name: "ProductionDB"}

    // Context avec timeout pour les requ√™tes DB
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    // Ajouter des informations de tra√ßage
    ctx = context.WithValue(ctx, "trace_id", "trace_12345")

    // Ex√©cuter plusieurs requ√™tes
    queries := []string{
        "SELECT * FROM users",
        "SELECT * FROM orders",
        "SELECT * FROM products",
    }

    for _, query := range queries {
        result, err := db.Query(ctx, query)
        if err != nil {
            fmt.Printf("‚ùå Erreur pour la requ√™te '%s': %v\n", query, err)
            continue
        }
        fmt.Printf("‚úÖ R√©sultats pour '%s': %v\n", query, result)
    }
}
```

## Patterns avanc√©s

### 1. Context pipeline

```go
func contextPipeline() {
    ctx := context.Background()
    ctx = context.WithValue(ctx, "step", 0)

    // Pipeline de traitement
    result := ctx
    result = step1(result)
    result = step2(result)
    result = step3(result)

    fmt.Printf("R√©sultat final: step = %v\n", result.Value("step"))
}

func step1(ctx context.Context) context.Context {
    step := ctx.Value("step").(int)
    fmt.Printf("üîÑ √âtape 1 (step=%d)\n", step)
    return context.WithValue(ctx, "step", step+1)
}

func step2(ctx context.Context) context.Context {
    step := ctx.Value("step").(int)
    fmt.Printf("üîÑ √âtape 2 (step=%d)\n", step)
    return context.WithValue(ctx, "step", step+1)
}

func step3(ctx context.Context) context.Context {
    step := ctx.Value("step").(int)
    fmt.Printf("üîÑ √âtape 3 (step=%d)\n", step)
    return context.WithValue(ctx, "step", step+1)
}
```

### 2. Context avec retry

```go
func retryWithContext(ctx context.Context, maxAttempts int, operation func() error) error {
    for attempt := 1; attempt <= maxAttempts; attempt++ {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            err := operation()
            if err == nil {
                return nil
            }

            fmt.Printf("‚ö†Ô∏è Tentative %d √©chou√©e: %v\n", attempt, err)

            if attempt < maxAttempts {
                // Backoff avec context
                backoff := time.Duration(attempt) * 100 * time.Millisecond
                timer := time.NewTimer(backoff)

                select {
                case <-timer.C:
                    // Continuer
                case <-ctx.Done():
                    timer.Stop()
                    return ctx.Err()
                }
            }
        }
    }

    return fmt.Errorf("√©chec apr√®s %d tentatives", maxAttempts)
}
```

## Bonnes pratiques

### ‚úÖ √Ä faire

1. **Toujours passer Context en premier param√®tre**
   ```go
   func myFunction(ctx context.Context, param string) error
   ```

2. **Utiliser defer cancel()**
   ```go
   ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
   defer cancel() // Toujours appeler cancel()
   ```

3. **V√©rifier ctx.Done() dans les boucles**
   ```go
   for {
       select {
       case <-ctx.Done():
           return ctx.Err()
       default:
           // Faire le travail
       }
   }
   ```

4. **Utiliser des cl√©s typ√©es pour les valeurs**
   ```go
   type myKey struct{}
   ctx = context.WithValue(ctx, myKey{}, "value")
   ```

### ‚ùå √Ä √©viter

1. **Ne jamais passer nil context**
   ```go
   // ‚ùå Mauvais
   myFunction(nil, "param")

   // ‚úÖ Bon
   myFunction(context.Background(), "param")
   ```

2. **Ne pas stocker context dans des structs**
   ```go
   // ‚ùå Mauvais
   type MyStruct struct {
       ctx context.Context
   }

   // ‚úÖ Bon : passer en param√®tre
   func (m *MyStruct) DoWork(ctx context.Context)
   ```

3. **Ne pas ignorer l'annulation**
   ```go
   // ‚ùå Mauvais : ne v√©rifie pas l'annulation
   for i := 0; i < 1000; i++ {
       heavyWork()
   }

   // ‚úÖ Bon : v√©rifie l'annulation
   for i := 0; i < 1000; i++ {
       select {
       case <-ctx.Done():
           return ctx.Err()
       default:
           heavyWork()
       }
   }
   ```

## Exercices pratiques

### Exercice 1 : Worker avec timeout

Cr√©ez un worker qui traite des t√¢ches avec un timeout global.

```go
func timeoutWorkerExercise() {
    // Votre impl√©mentation ici
    // Indices :
    // - Context avec timeout de 5 secondes
    // - Worker qui traite 10 t√¢ches
    // - Chaque t√¢che prend 1 seconde
    // - G√©rer l'annulation proprement
}
```

### Exercice 2 : Pipeline avec valeurs

Cr√©ez un pipeline de traitement qui enrichit les donn√©es √† chaque √©tape.

```go
func enrichmentPipelineExercise() {
    // Votre impl√©mentation ici
    // Indices :
    // - Context avec des valeurs initiales
    // - 3 √©tapes qui ajoutent des informations
    // - Timeout global de 3 secondes
    // - Retourner l'objet enrichi final
}
```

## R√©sum√©

Le package `context` est essentiel pour :

- **G√©rer les timeouts** et deadlines
- **Annuler des op√©rations** en cours
- **Passer des valeurs** entre goroutines
- **Coordonner** plusieurs t√¢ches concurrentes

**Types principaux** :
- `context.Background()` : Point de d√©part
- `WithCancel()` : Annulation manuelle
- `WithTimeout()` : Timeout automatique
- `WithDeadline()` : Expiration √† un moment pr√©cis
- `WithValue()` : Transport de valeurs

**Pattern de base** :
```go
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

select {
case <-ctx.Done():
    return ctx.Err()
default:
    // Faire le travail
}
```

La ma√Ætrise du package `context` vous permettra de construire des applications Go robustes et professionnelles !

‚è≠Ô∏è

# Solutions des exercices pratiques - Context

## Exercice 1 : Worker avec timeout

### Solution compl√®te

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// Task repr√©sente une t√¢che √† traiter
type Task struct {
    ID       int
    Name     string
    Duration time.Duration
}

// TaskResult repr√©sente le r√©sultat d'une t√¢che
type TaskResult struct {
    TaskID    int
    Success   bool
    Error     error
    Elapsed   time.Duration
    Worker    int
}

// timeoutWorker traite les t√¢ches avec gestion du timeout
func timeoutWorker(ctx context.Context, id int, tasks <-chan Task, results chan<- TaskResult, wg *sync.WaitGroup) {
    defer wg.Done()

    processed := 0
    for {
        select {
        case task, ok := <-tasks:
            if !ok {
                fmt.Printf("üèÅ Worker %d termin√© (%d t√¢ches trait√©es)\n", id, processed)
                return
            }

            fmt.Printf("‚öôÔ∏è Worker %d commence la t√¢che %d (%s)\n", id, task.ID, task.Name)
            start := time.Now()

            // Traiter la t√¢che avec v√©rification du context
            result := processTaskWithContext(ctx, task, id)
            result.Elapsed = time.Since(start)

            // Envoyer le r√©sultat (non-bloquant avec context)
            select {
            case results <- result:
                processed++
                if result.Success {
                    fmt.Printf("‚úÖ Worker %d: t√¢che %d termin√©e avec succ√®s en %v\n",
                              id, task.ID, result.Elapsed)
                } else {
                    fmt.Printf("‚ùå Worker %d: t√¢che %d √©chou√©e - %v\n",
                              id, task.ID, result.Error)
                }
            case <-ctx.Done():
                fmt.Printf("üõë Worker %d: arr√™t pendant l'envoi du r√©sultat (t√¢che %d)\n", id, task.ID)
                return
            }

        case <-ctx.Done():
            fmt.Printf("üõë Worker %d arr√™t√© par timeout: %v (%d t√¢ches trait√©es)\n",
                      id, ctx.Err(), processed)
            return
        }
    }
}

// processTaskWithContext traite une t√¢che en respectant le context
func processTaskWithContext(ctx context.Context, task Task, workerID int) TaskResult {
    result := TaskResult{
        TaskID: task.ID,
        Worker: workerID,
    }

    // Cr√©er un timer pour la dur√©e de la t√¢che
    timer := time.NewTimer(task.Duration)
    defer timer.Stop()

    select {
    case <-timer.C:
        // T√¢che termin√©e normalement
        result.Success = true
        return result

    case <-ctx.Done():
        // Timeout global ou annulation
        result.Success = false
        result.Error = fmt.Errorf("t√¢che annul√©e: %v", ctx.Err())
        return result
    }
}

func timeoutWorkerExercise() {
    const (
        numWorkers    = 3
        numTasks      = 10
        globalTimeout = 5 * time.Second
    )

    // Cr√©er un context avec timeout global
    ctx, cancel := context.WithTimeout(context.Background(), globalTimeout)
    defer cancel()

    // Channels
    tasks := make(chan Task, numTasks)
    results := make(chan TaskResult, numTasks)

    var wg sync.WaitGroup

    fmt.Printf("üöÄ D√©marrage de %d workers avec timeout global de %v\n", numWorkers, globalTimeout)
    start := time.Now()

    // D√©marrer les workers
    for i := 1; i <= numWorkers; i++ {
        wg.Add(1)
        go timeoutWorker(ctx, i, tasks, results, &wg)
    }

    // G√©n√©rer les t√¢ches
    go func() {
        defer close(tasks)

        for i := 1; i <= numTasks; i++ {
            task := Task{
                ID:       i,
                Name:     fmt.Sprintf("T√¢che-%d", i),
                Duration: 1 * time.Second, // Chaque t√¢che prend 1 seconde
            }

            select {
            case tasks <- task:
                fmt.Printf("üìã T√¢che %d ajout√©e √† la queue\n", i)
            case <-ctx.Done():
                fmt.Printf("‚ö†Ô∏è Arr√™t de la g√©n√©ration de t√¢ches: %v\n", ctx.Err())
                return
            }
        }
        fmt.Println("üìã Toutes les t√¢ches ont √©t√© ajout√©es")
    }()

    // Collecter les r√©sultats dans une goroutine s√©par√©e
    go func() {
        wg.Wait()
        close(results)
    }()

    // Analyser les r√©sultats
    var successful, failed int
    var totalTime time.Duration
    var completedTasks []TaskResult

    fmt.Println("üìä Collecte des r√©sultats...")

    for result := range results {
        completedTasks = append(completedTasks, result)
        totalTime += result.Elapsed

        if result.Success {
            successful++
        } else {
            failed++
        }
    }

    elapsed := time.Since(start)

    // Afficher les statistiques
    fmt.Printf("\nüéâ Exercice termin√© en %v\n", elapsed)
    fmt.Printf("üìà Statistiques:\n")
    fmt.Printf("   üìù T√¢ches pr√©vues: %d\n", numTasks)
    fmt.Printf("   ‚úÖ T√¢ches r√©ussies: %d\n", successful)
    fmt.Printf("   ‚ùå T√¢ches √©chou√©es: %d\n", failed)
    fmt.Printf("   ‚è±Ô∏è Temps total de traitement: %v\n", totalTime)

    if len(completedTasks) > 0 {
        avgTime := totalTime / time.Duration(len(completedTasks))
        fmt.Printf("   üìä Temps moyen par t√¢che: %v\n", avgTime)
    }

    // D√©tail par worker
    workerStats := make(map[int]int)
    for _, result := range completedTasks {
        if result.Success {
            workerStats[result.Worker]++
        }
    }

    fmt.Println("   üë∑ R√©partition par worker:")
    for workerID, count := range workerStats {
        fmt.Printf("     Worker %d: %d t√¢ches r√©ussies\n", workerID, count)
    }

    // V√©rifier si le timeout a √©t√© atteint
    if elapsed >= globalTimeout {
        fmt.Printf("‚è∞ Le timeout global de %v a √©t√© atteint\n", globalTimeout)
    } else {
        fmt.Printf("‚ö° Termin√© avant le timeout (reste %v)\n", globalTimeout-elapsed)
    }
}
```

### Version avec retry automatique

```go
// Version avanc√©e avec retry en cas d'√©chec
func advancedTimeoutWorkerExercise() {
    const (
        numWorkers    = 2
        numTasks      = 8
        globalTimeout = 6 * time.Second
        maxRetries    = 2
    )

    ctx, cancel := context.WithTimeout(context.Background(), globalTimeout)
    defer cancel()

    tasks := make(chan Task, numTasks*2) // Buffer plus grand pour les retry
    results := make(chan TaskResult, numTasks)

    var wg sync.WaitGroup

    // Workers avec retry
    for i := 1; i <= numWorkers; i++ {
        wg.Add(1)
        go advancedTimeoutWorker(ctx, i, tasks, results, &wg, maxRetries)
    }

    // G√©n√©rer les t√¢ches avec chance d'√©chec
    go func() {
        defer close(tasks)

        for i := 1; i <= numTasks; i++ {
            task := Task{
                ID:       i,
                Name:     fmt.Sprintf("T√¢che-fragile-%d", i),
                Duration: 800 * time.Millisecond,
            }
            tasks <- task
        }
    }()

    // Collecter les r√©sultats
    go func() {
        wg.Wait()
        close(results)
    }()

    // Analyser les r√©sultats
    for result := range results {
        status := "‚úÖ"
        if !result.Success {
            status = "‚ùå"
        }
        fmt.Printf("%s T√¢che %d (Worker %d): %v\n",
                  status, result.TaskID, result.Worker, result.Error)
    }
}

func advancedTimeoutWorker(ctx context.Context, id int, tasks <-chan Task,
                          results chan<- TaskResult, wg *sync.WaitGroup, maxRetries int) {
    defer wg.Done()

    for {
        select {
        case task, ok := <-tasks:
            if !ok {
                return
            }

            // Essayer la t√¢che avec retry
            result := processTaskWithRetry(ctx, task, id, maxRetries)

            select {
            case results <- result:
            case <-ctx.Done():
                return
            }

        case <-ctx.Done():
            fmt.Printf("üõë Worker %d arr√™t√© par timeout\n", id)
            return
        }
    }
}

func processTaskWithRetry(ctx context.Context, task Task, workerID, maxRetries int) TaskResult {
    for attempt := 1; attempt <= maxRetries+1; attempt++ {
        select {
        case <-ctx.Done():
            return TaskResult{
                TaskID:  task.ID,
                Worker:  workerID,
                Success: false,
                Error:   ctx.Err(),
            }
        default:
            // Simulation: 30% de chance d'√©chec
            if attempt < maxRetries+1 && time.Now().UnixNano()%10 < 3 {
                fmt.Printf("‚ö†Ô∏è Worker %d: √©chec t√¢che %d (tentative %d)\n",
                          workerID, task.ID, attempt)
                time.Sleep(100 * time.Millisecond) // Petit d√©lai avant retry
                continue
            }

            // Traitement r√©ussi
            time.Sleep(task.Duration)
            return TaskResult{
                TaskID:  task.ID,
                Worker:  workerID,
                Success: true,
            }
        }
    }

    return TaskResult{
        TaskID:  task.ID,
        Worker:  workerID,
        Success: false,
        Error:   fmt.Errorf("√©chec apr√®s %d tentatives", maxRetries+1),
    }
}
```

---

## Exercice 2 : Pipeline avec valeurs

### Solution compl√®te

```go
package main

import (
    "context"
    "fmt"
    "strings"
    "time"
)

// DataObject repr√©sente l'objet enrichi √† chaque √©tape
type DataObject struct {
    ID          string
    RawData     string
    ProcessedBy []string
    Metadata    map[string]interface{}
    Timestamp   time.Time
}

// Cl√©s pour le context
type contextKey string

const (
    UserIDKey     contextKey = "userID"
    RequestIDKey  contextKey = "requestID"
    TraceIDKey    contextKey = "traceID"
    PipelineIDKey contextKey = "pipelineID"
)

// enrichmentStep1 ajoute des informations de base
func enrichmentStep1(ctx context.Context, data DataObject) (DataObject, error) {
    select {
    case <-ctx.Done():
        return data, ctx.Err()
    default:
        // Simulation du traitement (700ms)
        time.Sleep(700 * time.Millisecond)

        userID := ctx.Value(UserIDKey)
        requestID := ctx.Value(RequestIDKey)

        fmt.Printf("üîÑ √âtape 1: Normalisation des donn√©es (User: %v, Request: %v)\n",
                  userID, requestID)

        // Enrichir l'objet
        data.RawData = strings.ToUpper(strings.TrimSpace(data.RawData))
        data.ProcessedBy = append(data.ProcessedBy, "normalizer")
        data.Metadata["normalized"] = true
        data.Metadata["step1_duration"] = 700
        data.Metadata["processor"] = "step1-normalizer-v1.0"

        fmt.Printf("‚úÖ √âtape 1 termin√©e: %s\n", data.RawData)
        return data, nil
    }
}

// enrichmentStep2 ajoute une validation et des m√©tadonn√©es
func enrichmentStep2(ctx context.Context, data DataObject) (DataObject, error) {
    select {
    case <-ctx.Done():
        return data, ctx.Err()
    default:
        // Simulation du traitement (800ms)
        time.Sleep(800 * time.Millisecond)

        traceID := ctx.Value(TraceIDKey)
        fmt.Printf("üîç √âtape 2: Validation et enrichissement (Trace: %v)\n", traceID)

        // Validation
        if len(data.RawData) < 3 {
            return data, fmt.Errorf("donn√©es trop courtes pour validation")
        }

        // Enrichir l'objet
        data.ProcessedBy = append(data.ProcessedBy, "validator")
        data.Metadata["validated"] = true
        data.Metadata["length"] = len(data.RawData)
        data.Metadata["step2_duration"] = 800
        data.Metadata["validation_rules"] = []string{"min_length", "uppercase_check"}

        // Ajouter des donn√©es calcul√©es
        if strings.Contains(data.RawData, "URGENT") {
            data.Metadata["priority"] = "high"
        } else {
            data.Metadata["priority"] = "normal"
        }

        fmt.Printf("‚úÖ √âtape 2 termin√©e: validation OK, priorit√© %v\n",
                  data.Metadata["priority"])
        return data, nil
    }
}

// enrichmentStep3 finalise le traitement
func enrichmentStep3(ctx context.Context, data DataObject) (DataObject, error) {
    select {
    case <-ctx.Done():
        return data, ctx.Err()
    default:
        // Simulation du traitement (900ms)
        time.Sleep(900 * time.Millisecond)

        pipelineID := ctx.Value(PipelineIDKey)
        fmt.Printf("üéØ √âtape 3: Finalisation et indexation (Pipeline: %v)\n", pipelineID)

        // Enrichir l'objet final
        data.ProcessedBy = append(data.ProcessedBy, "finalizer")
        data.Metadata["finalized"] = true
        data.Metadata["step3_duration"] = 900
        data.Metadata["index_key"] = fmt.Sprintf("idx_%s_%d", data.ID, time.Now().Unix())
        data.Metadata["total_processing_steps"] = len(data.ProcessedBy)

        // Calculer le temps total estim√©
        totalDuration := 0
        for _, key := range []string{"step1_duration", "step2_duration", "step3_duration"} {
            if duration, ok := data.Metadata[key].(int); ok {
                totalDuration += duration
            }
        }
        data.Metadata["total_duration_ms"] = totalDuration

        fmt.Printf("‚úÖ √âtape 3 termin√©e: objet index√© avec cl√© %v\n",
                  data.Metadata["index_key"])
        return data, nil
    }
}

func enrichmentPipelineExercise() {
    const pipelineTimeout = 3 * time.Second

    // Cr√©er le context de base avec des valeurs
    ctx := context.Background()
    ctx = context.WithValue(ctx, UserIDKey, "user_12345")
    ctx = context.WithValue(ctx, RequestIDKey, "req_67890")
    ctx = context.WithValue(ctx, TraceIDKey, "trace_abcdef")
    ctx = context.WithValue(ctx, PipelineIDKey, "pipeline_xyz789")

    // Ajouter le timeout global
    ctx, cancel := context.WithTimeout(ctx, pipelineTimeout)
    defer cancel()

    // Donn√©es initiales √† traiter
    initialData := DataObject{
        ID:          "data_001",
        RawData:     "  urgent customer data processing request  ",
        ProcessedBy: []string{},
        Metadata:    make(map[string]interface{}),
        Timestamp:   time.Now(),
    }

    fmt.Printf("üöÄ D√©marrage du pipeline d'enrichissement\n")
    fmt.Printf("üìã Donn√©es initiales: %q\n", initialData.RawData)
    fmt.Printf("‚è∞ Timeout global: %v\n", pipelineTimeout)

    start := time.Now()

    // Ex√©cuter le pipeline √©tape par √©tape
    result, err := executePipeline(ctx, initialData)

    elapsed := time.Since(start)

    // Afficher les r√©sultats
    if err != nil {
        fmt.Printf("\n‚ùå Pipeline √©chou√© apr√®s %v: %v\n", elapsed, err)

        // Afficher l'√©tat partiel s'il y en a un
        if len(result.ProcessedBy) > 0 {
            fmt.Printf("üìä √âtat partiel apr√®s %d √©tapes:\n", len(result.ProcessedBy))
            fmt.Printf("   Trait√© par: %v\n", result.ProcessedBy)
            fmt.Printf("   M√©tadonn√©es: %v\n", result.Metadata)
        }
    } else {
        fmt.Printf("\nüéâ Pipeline termin√© avec succ√®s en %v\n", elapsed)
        displayEnrichedObject(result)
    }

    // V√©rifier si le timeout a √©t√© atteint
    if err == context.DeadlineExceeded {
        fmt.Printf("‚è∞ Le timeout de %v a √©t√© d√©pass√©\n", pipelineTimeout)
        fmt.Printf("üí° Suggestion: augmenter le timeout ou optimiser les √©tapes\n")
    }
}

func executePipeline(ctx context.Context, data DataObject) (DataObject, error) {
    var err error

    // √âtape 1: Normalisation
    data, err = enrichmentStep1(ctx, data)
    if err != nil {
        return data, fmt.Errorf("erreur √©tape 1: %w", err)
    }

    // √âtape 2: Validation
    data, err = enrichmentStep2(ctx, data)
    if err != nil {
        return data, fmt.Errorf("erreur √©tape 2: %w", err)
    }

    // √âtape 3: Finalisation
    data, err = enrichmentStep3(ctx, data)
    if err != nil {
        return data, fmt.Errorf("erreur √©tape 3: %w", err)
    }

    return data, nil
}

func displayEnrichedObject(data DataObject) {
    fmt.Printf("üìä Objet enrichi final:\n")
    fmt.Printf("   üÜî ID: %s\n", data.ID)
    fmt.Printf("   üìù Donn√©es: %q\n", data.RawData)
    fmt.Printf("   üîÑ Trait√© par: %v\n", data.ProcessedBy)
    fmt.Printf("   üìÖ Timestamp: %v\n", data.Timestamp.Format("15:04:05.000"))

    fmt.Printf("   üìã M√©tadonn√©es:\n")
    for key, value := range data.Metadata {
        fmt.Printf("     %s: %v\n", key, value)
    }
}

// Version avec pipeline concurrent
func concurrentEnrichmentPipeline() {
    const pipelineTimeout = 4 * time.Second

    ctx := context.Background()
    ctx = context.WithValue(ctx, UserIDKey, "user_concurrent")
    ctx = context.WithTimeout(ctx, pipelineTimeout)

    // Donn√©es √† traiter en parall√®le
    datasets := []DataObject{
        {ID: "data_001", RawData: "urgent customer request", Metadata: make(map[string]interface{})},
        {ID: "data_002", RawData: "normal processing task", Metadata: make(map[string]interface{})},
        {ID: "data_003", RawData: "high priority order", Metadata: make(map[string]interface{})},
    }

    fmt.Printf("üöÄ Pipeline concurrent avec %d objets\n", len(datasets))

    // Channel pour collecter les r√©sultats
    results := make(chan DataObject, len(datasets))
    errors := make(chan error, len(datasets))

    // Lancer le traitement en parall√®le
    for _, data := range datasets {
        go func(d DataObject) {
            result, err := executePipeline(ctx, d)
            if err != nil {
                errors <- err
            } else {
                results <- result
            }
        }(data)
    }

    // Collecter les r√©sultats
    var successful []DataObject
    var failed []error

    for i := 0; i < len(datasets); i++ {
        select {
        case result := <-results:
            successful = append(successful, result)
        case err := <-errors:
            failed = append(failed, err)
        case <-ctx.Done():
            failed = append(failed, ctx.Err())
        }
    }

    fmt.Printf("üìä R√©sultats du pipeline concurrent:\n")
    fmt.Printf("   ‚úÖ Succ√®s: %d\n", len(successful))
    fmt.Printf("   ‚ùå √âchecs: %d\n", len(failed))

    for _, result := range successful {
        fmt.Printf("   üéØ %s: %d √©tapes, priorit√© %v\n",
                  result.ID, len(result.ProcessedBy), result.Metadata["priority"])
    }
}
```

### Version avec monitoring en temps r√©el

```go
func monitoredEnrichmentPipeline() {
    const pipelineTimeout = 5 * time.Second

    ctx := context.Background()
    ctx = context.WithTimeout(ctx, pipelineTimeout)

    // Channel pour les m√©triques
    metrics := make(chan string, 10)

    // Moniteur en temps r√©el
    go func() {
        for metric := range metrics {
            fmt.Printf("üìä [M√âTRIQUE] %s\n", metric)
        }
    }()

    // Pipeline avec monitoring
    data := DataObject{
        ID:       "monitored_data",
        RawData:  "data with real-time monitoring",
        Metadata: make(map[string]interface{}),
    }

    start := time.Now()

    // √âtape 1 avec m√©trique
    metrics <- fmt.Sprintf("D√©but √©tape 1 √† %v", time.Since(start))
    data, err := enrichmentStep1(ctx, data)
    if err == nil {
        metrics <- fmt.Sprintf("√âtape 1 termin√©e √† %v", time.Since(start))
    }

    // √âtape 2 avec m√©trique
    metrics <- fmt.Sprintf("D√©but √©tape 2 √† %v", time.Since(start))
    data, err = enrichmentStep2(ctx, data)
    if err == nil {
        metrics <- fmt.Sprintf("√âtape 2 termin√©e √† %v", time.Since(start))
    }

    // √âtape 3 avec m√©trique
    metrics <- fmt.Sprintf("D√©but √©tape 3 √† %v", time.Since(start))
    data, err = enrichmentStep3(ctx, data)
    if err == nil {
        metrics <- fmt.Sprintf("√âtape 3 termin√©e √† %v", time.Since(start))
    }

    close(metrics)

    if err != nil {
        fmt.Printf("‚ùå Pipeline √©chou√©: %v\n", err)
    } else {
        fmt.Printf("‚úÖ Pipeline monitored termin√© en %v\n", time.Since(start))
    }
}

func main() {
    fmt.Println("=== Exercice 1: Worker avec timeout ===")
    timeoutWorkerExercise()

    fmt.Println("\n=== Version avanc√©e avec retry ===")
    advancedTimeoutWorkerExercise()

    fmt.Println("\n=== Exercice 2: Pipeline avec valeurs ===")
    enrichmentPipelineExercise()

    fmt.Println("\n=== Version concurrent ===")
    concurrentEnrichmentPipeline()

    fmt.Println("\n=== Version monitored ===")
    monitoredEnrichmentPipeline()
}
```

## Points cl√©s des solutions

### Exercice 1 - Worker avec timeout

**Fonctionnalit√©s impl√©ment√©es** :
- ‚úÖ Context avec timeout global de 5 secondes
- ‚úÖ 3 workers traitant 10 t√¢ches de 1 seconde chacune
- ‚úÖ Gestion propre de l'annulation √† tous les niveaux
- ‚úÖ Statistiques d√©taill√©es et r√©partition par worker
- ‚úÖ Version avanc√©e avec retry automatique

**Patterns utilis√©s** :
- Select avec ctx.Done() dans les boucles
- Gestion non-bloquante des channels avec context
- WaitGroup pour coordonner les workers
- Timer avec defer stop pour √©viter les fuites

### Exercice 2 - Pipeline avec valeurs

**Fonctionnalit√©s impl√©ment√©es** :
- ‚úÖ Context avec valeurs initiales (userID, requestID, traceID)
- ‚úÖ 3 √©tapes d'enrichissement (normalisation, validation, finalisation)
- ‚úÖ Timeout global de 3 secondes avec gestion d'√©tat partiel
- ‚úÖ Objet DataObject complet avec m√©tadonn√©es
- ‚úÖ Versions concurrent et monitored

**Enrichissements par √©tape** :
- **√âtape 1** : Normalisation + m√©tadonn√©es de traitement
- **√âtape 2** : Validation + calcul de priorit√©
- **√âtape 3** : Indexation + statistiques finales

Ces solutions d√©montrent l'utilisation avanc√©e du package context pour construire des syst√®mes robustes et observables !

‚è≠Ô∏è
